// Seed file for x402 contract templates
// Task 11.1: Seed x402 contract templates

import { db } from "@/lib/db";
import { contractTemplate, type SourceFile, type DeploymentConfig, type ConstructorParam } from "@/lib/db/schema";

// ============================================================================
// Interface Source Files (shared across templates)
// ============================================================================

const ISettlementHookSource = `// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

/**
 * @title ISettlementHook
 * @notice Interface for settlement hooks that execute business logic after payment
 * @dev Hooks are called by SettlementRouter after consuming EIP-3009 authorization
 */
interface ISettlementHook {
    /**
     * @notice Executes the hook's business logic
     * @dev Called by SettlementRouter with approved token amount
     * @param contextKey Unique identifier for this settlement (based on EIP-3009 nonce)
     * @param payer Address that signed the EIP-3009 authorization
     * @param token Address of the payment token (e.g., USDC)
     * @param amount Amount of tokens available to Hook (after facilitator fee deduction)
     * @param salt Unique identifier for this settlement (generated by Resource Server)
     * @param payTo Final recipient address (for transparency and UI display)
     * @param facilitator Address of the facilitator who submitted this transaction
     * @param data ABI-encoded hook-specific parameters
     * @return result ABI-encoded result data (optional)
     */
    function execute(
        bytes32 contextKey,
        address payer,
        address token,
        uint256 amount,
        bytes32 salt,
        address payTo,
        address facilitator,
        bytes calldata data
    ) external returns (bytes memory result);
}`;

const IERC3009Source = `// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

/**
 * @title IERC3009
 * @notice EIP-3009: Transfer With Authorization Interface
 * @dev Tokens like USDC implement this interface, supporting meta-transaction transfers
 */
interface IERC3009 {
    function transferWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        bytes calldata signature
    ) external;
    
    function cancelAuthorization(
        address authorizer,
        bytes32 nonce,
        bytes calldata signature
    ) external;
    
    function authorizationState(
        address authorizer,
        bytes32 nonce
    ) external view returns (bool);

    function receiveWithAuthorization(
        address from,
        address to,
        uint256 value,
        uint256 validAfter,
        uint256 validBefore,
        bytes32 nonce,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}`;

// ============================================================================
// NFT Mint Hook Template
// ============================================================================

const NFTMintHookSource = `// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {IERC721} from "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import {ISettlementHook} from "./ISettlementHook.sol";

/**
 * @title NFTMintHook
 * @notice NFT Mint Hook - Automatically mint NFT after payment
 * @dev Transfer all received funds to merchant, while minting NFT to payer
 */
contract NFTMintHook is ISettlementHook {
    using SafeERC20 for IERC20;
    
    address public immutable settlementRouter;
    
    struct MintConfig {
        address nftContract;
    }
    
    event NFTMinted(bytes32 indexed contextKey, address indexed nftContract, address indexed recipient);
    event PaymentTransferred(bytes32 indexed contextKey, address indexed payTo, uint256 amount);
    
    error OnlyRouter();
    error InvalidAddress();
    
    modifier onlyRouter() {
        if (msg.sender != settlementRouter) revert OnlyRouter();
        _;
    }
    
    constructor(address _settlementRouter) {
        require(_settlementRouter != address(0), "Invalid router address");
        settlementRouter = _settlementRouter;
    }
    
    function execute(
        bytes32 contextKey,
        address payer,
        address token,
        uint256 amount,
        bytes32 salt,
        address payTo,
        address facilitator,
        bytes calldata data
    ) external onlyRouter returns (bytes memory) {
        MintConfig memory config = abi.decode(data, (MintConfig));
        
        if (config.nftContract == address(0)) revert InvalidAddress();
        if (payTo == address(0)) revert InvalidAddress();
        
        IERC20(token).safeTransferFrom(settlementRouter, payTo, amount);
        emit PaymentTransferred(contextKey, payTo, amount);
        
        _safeMint(config.nftContract, payer);
        emit NFTMinted(contextKey, config.nftContract, payer);
        
        return abi.encode(config.nftContract);
    }
    
    function _safeMint(address nftContract, address to) internal {
        (bool success, bytes memory returnData) = nftContract.call(
            abi.encodeWithSignature("mint(address)", to)
        );
        
        if (!success) {
            if (returnData.length > 0) {
                assembly {
                    let returnDataSize := mload(returnData)
                    revert(add(32, returnData), returnDataSize)
                }
            } else {
                revert("NFT mint failed");
            }
        }
    }
}`;

const RandomNFTSource = `// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";

/**
 * @title RandomNFT
 * @notice A simple NFT contract with sequential token ID generation and supply cap
 */
contract RandomNFT is ERC721 {
    uint256 public constant MAX_SUPPLY = 10_000;
    address public minter;
    uint256 private _nextTokenId;
    
    event MinterSet(address indexed minter);
    
    error OnlyMinter();
    error MaxSupplyReached();
    
    constructor(address _minter) ERC721("X402 Random NFT", "X402RNFT") {
        require(_minter != address(0), "Invalid minter address");
        minter = _minter;
        emit MinterSet(_minter);
    }
    
    function mint(address to) external {
        if (msg.sender != minter) revert OnlyMinter();
        if (_nextTokenId >= MAX_SUPPLY) revert MaxSupplyReached();
        
        uint256 tokenId = _nextTokenId++;
        _safeMint(to, tokenId);
    }
    
    function totalSupply() external view returns (uint256) {
        return _nextTokenId;
    }
    
    function remainingSupply() external view returns (uint256) {
        return MAX_SUPPLY - _nextTokenId;
    }
}`;

// ============================================================================
// Reward Points Hook Template
// ============================================================================

const RewardHookSource = `// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ISettlementHook} from "./ISettlementHook.sol";

interface IRewardToken {
    function distribute(address to, uint256 amount) external;
}

/**
 * @title RewardHook
 * @notice Settlement hook that transfers payment to merchant and distributes reward tokens
 */
contract RewardHook is ISettlementHook {
    using SafeERC20 for IERC20;
    
    address public immutable settlementRouter;
    uint256 public constant REWARD_RATE = 1000;
    uint256 public constant MAX_REWARD_AMOUNT = 100_000;
    
    struct RewardConfig {
        address rewardToken;
    }
    
    event RewardDistributed(
        bytes32 indexed contextKey,
        address indexed payer,
        address indexed payTo,
        address rewardToken,
        uint256 paymentAmount,
        uint256 rewardPoints
    );
    
    error OnlyRouter();
    error InvalidAddress();
    error RewardDistributionFailed();
    
    modifier onlyRouter() {
        if (msg.sender != settlementRouter) revert OnlyRouter();
        _;
    }
    
    constructor(address _settlementRouter) {
        require(_settlementRouter != address(0), "Invalid router address");
        settlementRouter = _settlementRouter;
    }
    
    function execute(
        bytes32 contextKey,
        address payer,
        address token,
        uint256 amount,
        bytes32 salt,
        address payTo,
        address facilitator,
        bytes calldata data
    ) external onlyRouter returns (bytes memory) {
        RewardConfig memory config = abi.decode(data, (RewardConfig));
        
        if (config.rewardToken == address(0)) revert InvalidAddress();
        if (payTo == address(0)) revert InvalidAddress();
        
        IERC20(token).safeTransferFrom(settlementRouter, payTo, amount);
        
        uint256 rewardableAmount = amount > MAX_REWARD_AMOUNT ? MAX_REWARD_AMOUNT : amount;
        uint256 rewardPoints;
        unchecked {
            rewardPoints = (rewardableAmount * REWARD_RATE * 10**18) / 100_000;
        }
        
        try IRewardToken(config.rewardToken).distribute(payer, rewardPoints) {
            emit RewardDistributed(contextKey, payer, payTo, config.rewardToken, amount, rewardPoints);
        } catch {
            revert RewardDistributionFailed();
        }
        
        return abi.encode(rewardPoints);
    }
}`;

const RewardTokenSource = `// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/**
 * @title RewardToken
 * @notice A reward points token with fixed supply and controlled distribution
 */
contract RewardToken is ERC20 {
    uint256 public constant MAX_SUPPLY = 100_000_000 * 10**18;
    address public immutable rewardHook;
    
    event RewardsDistributed(address indexed to, uint256 amount);
    
    error OnlyRewardHook();
    error InsufficientRewards();
    
    constructor(address _hook) ERC20("X402 Reward Points", "X402RP") {
        require(_hook != address(0), "Invalid hook address");
        rewardHook = _hook;
        _mint(address(this), MAX_SUPPLY);
    }
    
    function distribute(address to, uint256 amount) external {
        if (msg.sender != rewardHook) revert OnlyRewardHook();
        if (balanceOf(address(this)) < amount) revert InsufficientRewards();
        
        _transfer(address(this), to, amount);
        emit RewardsDistributed(to, amount);
    }
    
    function remainingRewards() external view returns (uint256) {
        return balanceOf(address(this));
    }
}`;

// ============================================================================
// Transfer Hook Template
// ============================================================================

const TransferHookSource = `// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ISettlementHook} from "./ISettlementHook.sol";

/**
 * @title TransferHook
 * @notice Built-in Hook for simple and distributed token transfers
 */
contract TransferHook is ISettlementHook {
    using SafeERC20 for IERC20;
    
    struct Split {
        address recipient;
        uint16 bips;
    }
    
    address public immutable settlementRouter;
    
    event Transfer(bytes32 indexed contextKey, address indexed recipient, uint256 amount);
    event DistributedTransfer(bytes32 indexed contextKey, uint256 totalAmount, uint256 recipientCount);
    
    error OnlyRouter();
    error InvalidRouterAddress();
    error EmptySplits();
    error InvalidTotalBips(uint256 totalBips);
    error InvalidRecipient(address recipient);
    error InvalidBips(uint16 bips);
    
    modifier onlyRouter() {
        if (msg.sender != settlementRouter) revert OnlyRouter();
        _;
    }
    
    constructor(address _settlementRouter) {
        if (_settlementRouter == address(0)) revert InvalidRouterAddress();
        settlementRouter = _settlementRouter;
    }
    
    function execute(
        bytes32 contextKey,
        address,
        address token,
        uint256 amount,
        bytes32,
        address payTo,
        address,
        bytes calldata data
    ) external onlyRouter returns (bytes memory) {
        if (payTo == address(0)) revert InvalidRecipient(address(0));
        
        if (data.length == 0) {
            return _executeSimpleTransfer(contextKey, token, amount, payTo);
        }
        
        return _executeDistributedTransfer(contextKey, token, amount, payTo, data);
    }
    
    function _executeSimpleTransfer(
        bytes32 contextKey,
        address token,
        uint256 amount,
        address recipient
    ) private returns (bytes memory) {
        IERC20(token).safeTransferFrom(settlementRouter, recipient, amount);
        emit Transfer(contextKey, recipient, amount);
        return abi.encode(recipient, amount);
    }
    
    function _executeDistributedTransfer(
        bytes32 contextKey,
        address token,
        uint256 amount,
        address payTo,
        bytes calldata data
    ) private returns (bytes memory) {
        Split[] memory splits = abi.decode(data, (Split[]));
        
        if (splits.length == 0) revert EmptySplits();
        
        uint256 totalBips = 0;
        for (uint256 i = 0; i < splits.length; i++) {
            if (splits[i].recipient == address(0)) revert InvalidRecipient(address(0));
            if (splits[i].bips == 0) revert InvalidBips(0);
            totalBips += splits[i].bips;
        }
        
        if (totalBips > 10000) revert InvalidTotalBips(totalBips);
        
        uint256 remaining = amount;
        for (uint256 i = 0; i < splits.length; i++) {
            uint256 splitAmount = (amount * splits[i].bips) / 10000;
            IERC20(token).safeTransferFrom(settlementRouter, splits[i].recipient, splitAmount);
            remaining -= splitAmount;
            emit Transfer(contextKey, splits[i].recipient, splitAmount);
        }
        
        uint256 recipientCount = splits.length;
        if (remaining > 0) {
            IERC20(token).safeTransferFrom(settlementRouter, payTo, remaining);
            emit Transfer(contextKey, payTo, remaining);
            recipientCount += 1;
        }
        
        emit DistributedTransfer(contextKey, amount, recipientCount);
        return abi.encode(recipientCount, amount);
    }
}`;

// ============================================================================
// Seed Function
// ============================================================================

export async function seedX402ContractTemplates() {
  console.log("Seeding x402 contract templates...");

  // 1. NFT Mint Hook Bundle
  const nftMintSourceFiles: SourceFile[] = [
    {
      filename: "ISettlementHook.sol",
      content: ISettlementHookSource,
      isMain: false,
      contractName: "ISettlementHook",
    },
    {
      filename: "NFTMintHook.sol",
      content: NFTMintHookSource,
      isMain: true,
      contractName: "NFTMintHook",
    },
    {
      filename: "RandomNFT.sol",
      content: RandomNFTSource,
      isMain: false,
      contractName: "RandomNFT",
    },
  ];

  const nftMintDeploymentConfig: DeploymentConfig = {
    deploymentOrder: ["NFTMintHook.sol", "RandomNFT.sol"],
    dependencies: {
      "NFTMintHook.sol": {
        constructorParams: [
          {
            paramName: "_settlementRouter",
            externalAddress: true,
            description: "x402 SettlementRouter contract address on Cronos",
          },
        ],
      },
      "RandomNFT.sol": {
        constructorParams: [
          {
            paramName: "_minter",
            sourceContract: "NFTMintHook.sol",
          },
        ],
      },
    },
  };

  const nftMintConstructorParams: ConstructorParam[] = [
    {
      name: "_settlementRouter",
      type: "address",
      description: "x402 SettlementRouter contract address",
      required: true,
    },
  ];

  await db.insert(contractTemplate).values({
    name: "x402 NFT Mint Hook",
    description: "Pay-to-mint NFT using x402 settlement. Automatically mints NFT after payment verification. Includes NFTMintHook and RandomNFT contracts.",
    category: "x402-settlement",
    soliditySourceCode: NFTMintHookSource,
    sourceFiles: nftMintSourceFiles,
    deploymentConfig: nftMintDeploymentConfig,
    constructorParamsSchema: nftMintConstructorParams,
  });

  // 2. Reward Points Hook Bundle
  const rewardPointsSourceFiles: SourceFile[] = [
    {
      filename: "ISettlementHook.sol",
      content: ISettlementHookSource,
      isMain: false,
      contractName: "ISettlementHook",
    },
    {
      filename: "RewardHook.sol",
      content: RewardHookSource,
      isMain: true,
      contractName: "RewardHook",
    },
    {
      filename: "RewardToken.sol",
      content: RewardTokenSource,
      isMain: false,
      contractName: "RewardToken",
    },
  ];

  const rewardPointsDeploymentConfig: DeploymentConfig = {
    deploymentOrder: ["RewardHook.sol", "RewardToken.sol"],
    dependencies: {
      "RewardHook.sol": {
        constructorParams: [
          {
            paramName: "_settlementRouter",
            externalAddress: true,
            description: "x402 SettlementRouter contract address on Cronos",
          },
        ],
      },
      "RewardToken.sol": {
        constructorParams: [
          {
            paramName: "_hook",
            sourceContract: "RewardHook.sol",
          },
        ],
      },
    },
  };

  const rewardPointsConstructorParams: ConstructorParam[] = [
    {
      name: "_settlementRouter",
      type: "address",
      description: "x402 SettlementRouter contract address",
      required: true,
    },
  ];

  await db.insert(contractTemplate).values({
    name: "x402 Reward Points Hook",
    description: "Pay-to-earn loyalty rewards using x402 settlement. Distributes reward tokens after payment. Includes RewardHook and RewardToken contracts.",
    category: "x402-settlement",
    soliditySourceCode: RewardHookSource,
    sourceFiles: rewardPointsSourceFiles,
    deploymentConfig: rewardPointsDeploymentConfig,
    constructorParamsSchema: rewardPointsConstructorParams,
  });

  // 3. Transfer Hook (Single Contract)
  const transferHookSourceFiles: SourceFile[] = [
    {
      filename: "ISettlementHook.sol",
      content: ISettlementHookSource,
      isMain: false,
      contractName: "ISettlementHook",
    },
    {
      filename: "TransferHook.sol",
      content: TransferHookSource,
      isMain: true,
      contractName: "TransferHook",
    },
  ];

  const transferHookDeploymentConfig: DeploymentConfig = {
    deploymentOrder: ["TransferHook.sol"],
    dependencies: {
      "TransferHook.sol": {
        constructorParams: [
          {
            paramName: "_settlementRouter",
            externalAddress: true,
            description: "x402 SettlementRouter contract address on Cronos",
          },
        ],
      },
    },
  };

  const transferHookConstructorParams: ConstructorParam[] = [
    {
      name: "_settlementRouter",
      type: "address",
      description: "x402 SettlementRouter contract address",
      required: true,
    },
  ];

  await db.insert(contractTemplate).values({
    name: "x402 Transfer Hook",
    description: "Simple and distributed payments with facilitator fee support. Supports single transfers and multi-recipient splits by percentage.",
    category: "x402-settlement",
    soliditySourceCode: TransferHookSource,
    sourceFiles: transferHookSourceFiles,
    deploymentConfig: transferHookDeploymentConfig,
    constructorParamsSchema: transferHookConstructorParams,
  });

  console.log("x402 contract templates seeded successfully!");
}
